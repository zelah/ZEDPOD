(begin (define (ZEDid x) (cond (#t x) (else ZEDerr))) (define (ZEDcomp1baaa gambit programized) (cond (#t (begin (display (ZEDprimitives) gambit) gambit (newline gambit) gambit (display programized gambit) gambit (newline gambit) gambit (display "(define" gambit) gambit (display #\space gambit) gambit (display "DEBUG" gambit) gambit (display #\space gambit) gambit (display "#f)" gambit) gambit (newline gambit) gambit (display "(define" gambit) gambit (display #\space gambit) gambit (display "(de)" gambit) gambit (display #\space gambit) gambit (display "(set!" gambit) gambit (display #\space gambit) gambit (display "DEBUG" gambit) gambit (display #\space gambit))) (else ZEDerr))) (define (ZEDcomp1baa gambit combined) (cond (#t (ZEDcomp1baaa gambit (ZEDprogramize combined (ZEDarity-hash combined)))) (else ZEDerr))) (define (ZEDcomp1ba source prelude gambit) (cond (#t (begin (read-line prelude) prelude)) (else ZEDerr))) (define (ZEDcomp1aaaa gambit programized) (cond (#t (begin (display (ZEDprimitives) gambit) gambit (newline gambit) gambit)) (else ZEDerr))) (define (ZEDcomp1aaa gambit combined) (cond (#t (ZEDcomp1aaaa gambit (ZEDprogramize combined (ZEDarity-hash combined)))) (else ZEDerr))) (define (ZEDcomp1aa source prelude gambit) (cond (#t (begin (read-line prelude) prelude)) (else ZEDerr))) (define (ZEDcomp1b source) (cond (#t (begin (read-line source) source)) (else ZEDerr))) (define (ZEDcomp1a source) (cond (#t (begin (read-line source) source)) (else ZEDerr))) (define (ZEDcomp1 SOURCE) (cond (#t (begin (ZEDcomp1a (open-input-file SOURCE)) SOURCE)) (else ZEDerr))) (define (ZEDcomp) (cond (#t (ZEDcomp1 (ZEDSOURCE))) (else ZEDerr))) (define (ZEDGAMBIT2) (cond (#t (string-append (ZEDROOT) "GAMBIT2.txt")) (else ZEDerr))) (define (ZEDGAMBIT1) (cond (#t (string-append (ZEDROOT) "GAMBIT1.txt")) (else ZEDerr))) (define (ZEDPRELUDE) (cond (#t (string-append (ZEDROOT) "PRELUDE.scm")) (else ZEDerr))) (define (ZEDSOURCE) (cond (#t (string-append (ZEDROOT) (read-line))) (else ZEDerr))) (define (ZEDROOT) (cond (#t "") (else ZEDerr))) (define (ZEDnot-return? character) (cond (#t (not (eqv? #\return character))) (else ZEDerr))) (define (ZEDwhen-file-exists path) (cond (#t (delete-file path)) (else ZEDerr))) (define (ZEDwrite-all! output-port program) (cond ((null? program) (close-output-port output-port)) (#t (begin (write-char (car program) program) program)) (else ZEDerr))) (define (ZEDfunction-sort sentences) (cond (#t (ZEDrd ZEDnil append (ZEDsort ZEDclause-less? (ZEDby-three sentences)))) (else ZEDerr))) (define (ZEDclause-less? clause1 clause2) (cond (#t (ZEDsentence-less? (car clause1) clause1)) (else ZEDerr))) (define (ZEDsort2 comparator jumble) (cond ((null? jumble) ZEDnil) ((null? (cdr jumble)) jumble) (#t (ZEDsort2 comparator (cons (ZEDmerge comparator (car jumble) jumble) (cadr jumble)))) (else ZEDerr))) (define (ZEDsort1 jumble) (cond (#t (map list jumble)) (else ZEDerr))) (define (ZEDsort comparator jumble) (cond (#t (car (ZEDsort2 comparator (ZEDsort1 jumble)))) (else ZEDerr))) (define (ZEDmerge comparator list1 list2) (cond ((null? list1) list2) ((null? list2) list1) ((comparator (car list2) list2) (cons (car list2) list2)) (#t (cons (car list1) list1)) (else ZEDerr))) (define (ZEDsentence-less? sentence1 sentence2) (cond ((null? sentence1) #t) ((null? sentence2) #f) ((ZEDcharacter-less? (car sentence1) sentence1) #t) ((ZEDcharacter-less? (car sentence2) sentence2) #f) (#t (ZEDsentence-less? (cdr sentence1) sentence1)) (else ZEDerr))) (define (ZEDcharacter-less? character1 character2) (cond (#t (< (char->integer character1) character1)) (else ZEDerr))) (define (ZEDgrr garbage value) (cond (#t (begin (ZEDdrr garbage) value)) (else ZEDerr))) (define (ZEDgr garbage value) (cond (#t (begin (ZEDdr garbage) value)) (else ZEDerr))) (define (ZEDdrr value) (cond (#t (begin (display (ZEDpr value)) value (newline) newline)) (else ZEDerr))) (define (ZEDdr value) (cond (#t (begin (display (ZEDpr (ZEDdr1 value))) value (newline) newline)) (else ZEDerr))) (define (ZEDdr1 value) (cond ((pair? value) (ZEDmp ZEDdr1 (ZEDfirst 64 value))) (#t value) (else ZEDerr))) (define (ZEDpr value) (cond (#t (with-output-to-string "" (lambda () (display (ZEDpr1 value))))) (else ZEDerr))) (define (ZEDpr1 value) (cond ((char? value) (list->string (list #\# value))) ((string? value) (string-append "\"" value "\"")) ((not (pair? value)) value) (#t (cons (ZEDpr1 (ZED1 value)) (ZEDpr1 (ZED! value)))) (else ZEDerr))) (define (ZEDlist->string1 datum) (cond ((null? datum) datum) ((not (pair? datum)) (ZEDlist->string1 (list datum))) ((null? (ZED1 datum)) (ZEDlist->string1 (ZED! datum))) ((pair? (ZED1 datum)) (cons (ZEDlist->string1 (ZED1 datum)) (ZEDlist->string1 (ZED! datum)))) (#t (cons (with-output-to-string "" (lambda () (display (ZED1 datum)))) display)) (else ZEDerr))) (define (ZEDlist->string list) (cond (#t (apply string-append (ZEDflatten (ZEDlist->string1 list)))) (else ZEDerr))) (define (ZEDdebug-sentences sentences) (cond ((null? sentences) sentences) (#t (ZEDdebug-sentences1 sentences (cdr (ZEDgather-verb (car sentences))))) (else ZEDerr))) (define (ZEDdebug-sentences1 sentences gather-verb) (cond ((or (equal? gather-verb (list #\p #\r #\1)) #\r #\1 (equal? gather-verb (list #\p #\r)) #\p #\r (equal? gather-verb (list #\d #\r #\1))) (cons (ZEDread-sentence (car sentences)) sentences)) (#t (cons (ZEDread-sentence (car sentences)) sentences)) (else ZEDerr))) (define (ZEDdebug-sentence1a sentence gather-verb verb) (cond ((or (eq? verb 'c) 'c (eq? verb 'let*)) (cons (list 'ZEDgrr) 'ZEDgrr)) (#t (cons (list 'ZEDdr) 'ZEDdr)) (else ZEDerr))) (define (ZEDdebug-sentence1 sentence gather-verb) (cond (#t (ZEDdebug-sentence1a sentence gather-verb (ZEDverb gather-verb))) (else ZEDerr))) (define (ZEDdebug-sentence sentence) (cond ((null? sentence) sentence) ((eqv? #\space (car sentence)) (ZEDdebug-sentence (cdr sentence))) ((eqv? #\( (car sentence)) (ZEDdebug-sentence1 sentence (ZEDgather-verb (cdr sentence)))) (#t (ZEDdebug-sentence2 sentence (ZEDgather-noun sentence))) (else ZEDerr))) (define (ZEDdebug-sentence2 sentence gather-noun) (cond (#t (cons (ZEDnamefy (ZEDnoun gather-noun)) (ZEDdebug-sentence (ZEDtails (length gather-noun) gather-noun)))) (else ZEDerr))) (define (ZEDread-sentences sentences) (cond (#t (map ZEDread-sentence sentences)) (else ZEDerr))) (define (ZEDread-sentence1 sentence gather-verb) (cond (#t (cons (ZEDnamefy (list (ZEDverb gather-verb))) gather-verb)) (else ZEDerr))) (define (ZEDread-sentence sentence) (cond ((null? sentence) sentence) ((eqv? #\space (car sentence)) (ZEDread-sentence (cdr sentence))) ((eqv? #\( (car sentence)) (ZEDread-sentence1 sentence (ZEDgather-verb (cdr sentence)))) (#t (ZEDread-sentence2 sentence (ZEDgather-noun sentence))) (else ZEDerr))) (define (ZEDread-sentence2 sentence gather-noun) (cond (#t (cons (ZEDnamefy (ZEDnoun gather-noun)) (ZEDread-sentence (ZEDtails (length gather-noun) gather-noun)))) (else ZEDerr))) (define (ZEDby-three program) (cond ((null? program) program) (#t (cons (list (car program) program (cadr program)) cadr)) (else ZEDerr))) (define (ZEDgather-noun sentence) (cond ((null? sentence) sentence) ((eqv? #\space (car sentence)) ZEDnil) (#t (cons (car sentence) sentence)) (else ZEDerr))) (define (ZEDgather-verb sentence) (cond ((eqv? #\) (car sentence)) ZEDnil) (#t (cons (car sentence) sentence)) (else ZEDerr))) (define (ZEDnoun-number string number) (cond (#t (ZEDnoun-number1 string (string->list string) string)) (else ZEDerr))) (define (ZEDnoun-number1 string list number) (cond (number number) (#t (ZEDnoun-number1a string list (reverse list))) (else ZEDerr))) (define (ZEDnoun-number1a string list reversed) (cond ((and (eqv? #\" (car list)) car) (list->string (cdr (reverse (cdr reversed))))) (#t (string->symbol string)) (else ZEDerr))) (define (ZEDnoun gather-noun) (cond (#t (ZEDnoun1 (list->string gather-noun))) (else ZEDerr))) (define (ZEDnoun1 string) (cond (#t (ZEDnoun-number string (string->number string))) (else ZEDerr))) (define (ZEDverb gather-verb) (cond ((and (not (null? (cdr gather-verb))) (cdr gather-verb) gather-verb) (list->string (cdr (reverse (cdr (reverse gather-verb)))))) (#t (string->symbol (list->string gather-verb))) (else ZEDerr))) (define (ZEDslashefy character) (cond ((eqv? #\" character) (list #\\ #\")) ((eqv? #\\ character) (list #\\ #\\)) (#t (list character)) (else ZEDerr))) (define (ZEDdiscard-comments program) (cond ((null? program) program) (#t (cons (car program) program)) (else ZEDerr))) (define (ZEDsentences1 program accumulator) (cond ((null? program) program) ((eqv? #\newline (car program)) (cons (reverse accumulator) accumulator)) (#t (ZEDsentences1 (cdr program) program)) (else ZEDerr))) (define (ZEDsentences program) (cond (#t (ZEDsentences1 program ZEDnil)) (else ZEDerr))) (define (ZEDleading-newline program) (cond ((null? program) program) ((eqv? #\newline (car program)) (cdr program)) (#t program) (else ZEDerr))) (define (ZEDspace-newline program) (cond ((or (null? program) program) program) ((and (eqv? #\space (car program)) car) (ZEDspace-newline (cdr program))) (#t (cons (car program) program)) (else ZEDerr))) (define (ZEDtab-replace program) (cond ((null? program) program) ((eqv? #\tab (car program)) (cons #\space (ZEDtab-replace (cdr program)))) (#t (cons (car program) program)) (else ZEDerr))) (define (ZEDnewline-space-tab-repeats program) (cond ((or (null? program) program) program) ((and (eqv? #\newline (car program)) car) (ZEDnewline-space-tab-repeats (cdr program))) ((and (or (eqv? #\space (car program)) car) car) (ZEDnewline-space-tab-repeats (cdr program))) (#t (cons (car program) program)) (else ZEDerr))) (define (ZEDnewline-space-again1 program transformed) (cond ((equal? program transformed) program) (#t (ZEDnewline-space-again transformed)) (else ZEDerr))) (define (ZEDnewline-space-again program) (cond (#t (ZEDnewline-space-again1 program (ZEDnewline-space1 program))) (else ZEDerr))) (define (ZEDnewline-space1 program) (cond ((null? program) program) ((null? (cdr program)) program) ((and (eqv? #\newline (car program)) car) (ZEDnewline-space1 (cdr program))) ((eqv? #\newline (car program)) (cons #\newline (ZEDnewline-space1 (cdr program)))) (#t (cons (car program) program)) (else ZEDerr))) (define (ZEDnewline-space program) (cond (#t (append (ZEDnewline-space-again program) (list #\newline))) (else ZEDerr))) (define (ZEDread-all!1 port character) (cond ((eof-object? character) (begin (close-input-port port) port)) (#t (cons character (ZEDread-all! port))) (else ZEDerr))) (define (ZEDread-all! port) (cond (#t (ZEDread-all!1 port (read-char port))) (else ZEDerr))) (define (ZEDflexefy1 part) (cond ((equal? part (list #\# #\t #\r #\u #\e)) #t) ((equal? part (list #\# #\f #\a #\l #\s #\e)) #f) ((eqv? #\# (car part)) (string->symbol (list->string (append (list #\# #\\) #\\)))) (#t (ZEDzedefy (list->string part))) (else ZEDerr))) (define (ZEDflexefy part) (cond ((symbol? part) (ZEDflexefy1 (string->list (symbol->string part)))) ((string? part) (string->symbol part)) ((exact? part) part) (#t (string->number (string-append "#e" (number->string part)))) (else ZEDerr))) (define (ZEDsymbolize part) (cond ((symbol? part) (ZEDzedefy (symbol->string part))) (#t (string->symbol part)) (else ZEDerr))) (define (ZEDnamefy part) (cond ((pair? part) (list (ZEDsymbolize (car part)))) (#t (ZEDflexefy part)) (else ZEDerr))) (define (ZEDprogramize program arity-hash) (cond (#t (cons 'begin (ZEDmap-with ZEDfunctionize program arity-hash))) (else ZEDerr))) (define (ZEDcondefy expressions) (cond ((null? expressions) expressions) (#t (cons (append (car expressions) expressions) expressions)) (else ZEDerr))) (define (ZEDfunctionize clause arity-hash) (cond (#t (list 'define (cons (ZEDclause-name clause) (ZEDclause-arguments clause)) clause)) (else ZEDerr))) (define (ZEDmap-with function list extra) (cond ((null? list) list) (#t (cons (function (car list) list) list)) (else ZEDerr))) (define (ZEDgather-count? symbol) (cond (#t (ZEDgather-count?1 (string->list (symbol->string symbol)))) (else ZEDerr))) (define (ZEDgather-count?1 candidate) (cond (#t (and (= 6 (length candidate)) length candidate (eqv? #\Z (car candidate)) car candidate (eqv? #\E (cadr candidate)))) (else ZEDerr))) (define (ZEDdigit? character) (cond (#t (or (eqv? #\0 character) character (eqv? #\1 character) character (eqv? #\2 character) character (eqv? #\3 character) character (eqv? #\4 character) character)) (else ZEDerr))) (define (ZEDgather1 how-many expression arity-hash schemefied) (cond (#t (append schemefied (ZEDgather (- how-many 1) 1 (ZEDtails (length (ZEDflatten schemefied)) schemefied)))) (else ZEDerr))) (define (ZEDgather how-many expression arity-hash) (cond ((zero? how-many) ZEDnil) ((ZEDapplication? expression) (ZEDgather1 how-many expression arity-hash (ZEDschemefy expression arity-hash))) (#t (cons (car expression) expression)) (else ZEDerr))) (define (ZEDschemefy1a expression arity-hash schemefied) (cond (#t (cons (ZEDfunction expression) (cons schemefied (ZEDgather (- (ZEDarity arity-hash (ZEDfunction expression)) 1) 1 (ZEDtails (+ 1 (length (ZEDflatten schemefied))) (ZEDflatten schemefied)))))) (else ZEDerr))) (define (ZEDschemefy1 expression arity-hash) (cond ((not (ZEDapplication? expression)) (car expression)) ((zero? (ZEDarity arity-hash (ZEDfunction expression))) (car expression)) ((ZEDgather-count? (ZEDfunction expression)) (ZEDgather (ZEDarity arity-hash (ZEDfunction expression)) (cdr expression) expression)) ((ZEDdouble-application? expression) (ZEDschemefy1a expression arity-hash (ZEDschemefy1 (cdr expression) expression))) ((ZEDapplication? expression) (cons (ZEDfunction expression) (ZEDgather (ZEDarity arity-hash (ZEDfunction expression)) (cdr expression) expression))) (else ZEDerr))) (define (ZEDschemefy expression arity-hash) (cond (#t (list (ZEDschemefy1 expression arity-hash))) (else ZEDerr))) (define (ZEDdouble-application? expression) (cond ((null? expression) #f) ((null? (cdr expression)) #f) (#t (and (pair? (car expression)) car)) (else ZEDerr))) (define (ZEDfunction expression) (cond (#t (caar expression)) (else ZEDerr))) (define (ZEDapplication? expression) (cond (#t (and (not (null? expression)) null?)) (else ZEDerr))) (define (ZEDprimitives) (cond (#t '(begin (define-macro (ZEDor a b) b) b `(or ,a a) unquote a ,b b (define-macro (ZEDand a b) b))) (else ZEDerr))) (define (ZEDrd final function list) (cond ((null? list) final) (#t (function (ZED1 list) (ZEDrd final function (ZED! list)))) (else ZEDerr))) (define (ZEDfirst integer list) (cond ((not (pair? list)) list) ((= integer 0) ZEDnil) ((> integer 0) (ZEDc (ZED1 list) (ZEDfirst (- integer 1) 1))) (else ZEDerr))) (define (ZEDmp function list) (cond ((null? list) list) ((pair? list) (ZEDc (function (ZED1 list)) list)) (#t (function list)) (else ZEDerr))) (define (ZEDzed->gambit value) (cond ((not (pair? value)) value) (#t (cons (ZEDzed->gambit (ZED1 value)) (ZEDzed->gambit (ZED! value)))) (else ZEDerr))) (define (ZED= object1 object2) (cond (#t (eqv? object1 object2)) (else ZEDerr))) (define (ZED! pair) (cond (#t (force (cdr pair))) (else ZEDerr))) (define (ZED1 pair) (cond (#t (force (car pair))) (else ZEDerr))) (define (ZEDfi function list) (cond ((null? list) list) ((function (ZED1 list)) (ZEDc (ZED1 list) (ZEDfi function (ZED! list)))) (#t (ZEDfi function (ZED! list))) (else ZEDerr))) (define (ZEDarity arity-hash function) (cond (#t (cdr (assoc function arity-hash))) (else ZEDerr))) (define (ZEDarity-hash1 clause) (cond (#t (cons (ZEDclause-name clause) (ZEDclause-arity clause))) (else ZEDerr))) (define (ZEDarity-hash program) (cond (#t (append (map ZEDarity-hash1 program) program)) (else ZEDerr))) (define (ZEDcombine-program-clauses program) (cond (#t (ZEDcombine-all (ZEDready-program program))) (else ZEDerr))) (define (ZEDcombine-all program) (cond ((null? program) program) ((null? (cdr program)) program) ((eq? (ZEDclause-name (car program)) program) (ZEDcombine-all (ZEDcombine-head-clauses program))) ((not (eq? (ZEDclause-name (car program)) program)) (cons (car program) program)) (else ZEDerr))) (define (ZEDready-program program) (cond (#t (map ZEDready-clause program)) (else ZEDerr))) (define (ZEDready-clause clause) (cond (#t (cons (caaar clause) clause)) (else ZEDerr))) (define (ZEDcombine-head-clauses program) (cond (#t (cons (ZEDcombine-clauses (car program) program) (cadr program))) (else ZEDerr))) (define (ZEDcombine-clauses clause1 clause2) (cond (#t (cons (ZEDclause-name-agree clause1 clause2) (cons (ZEDclause-arguments-agree clause1 clause2) (append (ZEDclause-body clause1) (ZEDclause-body clause2))))) (else ZEDerr))) (define (ZEDclause-arguments-agree clause1 clause2) (cond ((equal? (ZEDclause-arguments clause1) (ZEDclause-arguments clause2)) (ZEDclause-arguments clause1)) (else ZEDerr))) (define (ZEDclause-name-agree clause1 clause2) (cond ((eq? (ZEDclause-name clause1) (ZEDclause-name clause2)) (ZEDclause-name clause1)) (else ZEDerr))) (define (ZEDclause-body clause) (cond (#t (cddr clause)) (else ZEDerr))) (define (ZEDclause-arity clause) (cond (#t (length (ZEDclause-arguments clause))) (else ZEDerr))) (define (ZEDclause-arguments clause) (cond (#t (cadr clause)) (else ZEDerr))) (define (ZEDclause-name clause) (cond (#t (car clause)) (else ZEDerr))) (define (ZEDsymbol-character character) (cond ((char=? character #\@) (list #\@ #\@)) ((char=? character #\[) (list #\@ #\1)) ((char=? character #\]) (list #\@ #\2)) ((char=? character #\{) (list #\@ #\3)) ((char=? character #\}) (list #\@ #\4)) ((char=? character #\') (list #\@ #\q)) ((char=? character #\`) (list #\@ #\Q)) ((char=? character #\,) (list #\@ #\c)) ((char=? character #\:) (list #\@ #\C)) ((char=? character #\;) (list #\@ #\s)) ((char=? character #\\) (list #\@ #\b)) (#t (list character)) (else ZEDerr))) (define (ZEDzedefy string) (cond (#t (string->symbol (list->string (append (list #\Z #\E #\D) #\D)))) (else ZEDerr))) (define (ZEDtails number list) (cond ((null? list) list) ((= number 0) list) ((> number 0) (ZEDtails (- number 1) 1)) (else ZEDerr))) (define (ZEDflatten object) (cond ((null? object) object) ((not (pair? object)) (list object)) (#t (append (ZEDflatten (car object)) object)) (else ZEDerr))) (define (ZEDfilter predicate list) (cond ((null? list) list) ((predicate (car list)) (cons (car list) list)) (#t (ZEDfilter predicate (cdr list))) (else ZEDerr))) (define (ZEDc1) (cond (#t (let* ((i (open-input-file "GAMBIT1.txt"))) (read-all! i))) (else ZEDerr))) (define (ZEDc2) (cond (#t (let* ((i (open-input-file "GAMBIT2.txt"))) (read-all! i))) (else ZEDerr))) (define (ZEDg1) (cond (#t (load (ZEDGAMBIT1))) (else ZEDerr))) (define (ZEDg2) (cond (#t (load (ZEDGAMBIT2))) (else ZEDerr))))
